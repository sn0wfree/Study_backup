{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Session1-5 for Econometrics\"\nauthor: \"sn0wfree\"\ndate: \"11/12/2016\"\noutput:\n  pdf_document:\n    latex_engine: xelatex\n    number_sections: yes\n    toc: yes\n  html_document:\n    theme: readable\n    toc: yes\n---\n\n#Session1-5 \n\n## Basic Objects\n\n### list enviornment\n\n```{r list enviornment}\nls()# to list the current environment\n```\n\n## Vector and Matrix\n### Vector\nto create Vector based on c() function\nc() function is the function to create tuple or called Vector\n```{r Vector}\n# c():create a tuple, also can be seen a Vector if it is numberic tuple. because the tuple is the list with ordered element\nnv=c(6,5,4,3,2,1)\ncv=c(\"a string of characters\",\"also a string of characters\")\nnv[3]\ncv[1]\nvec=vector(mode = \"list\",length = 2)# in the mode, there are three options:\"list\", \"experession\" and \"any\"\nlength(nv) #show the number of elements\nmin(nv) #minimum value of nv\nwhich.min(nv) #the index of the minimum value of nv\nmax(nv) #maximum value of nv\nwhich.max(nv) #the index of the maximum value of nv sort(nv,decreasing=TRUE) #list nvâ€™s elements of nv decreasingly,decreasing is an optional argument with default value FALSE\nnv[2:5] #print 2-5 elements of nv\n```\n\nthe code for matrix is matrix():it look like a dataframe  \n```{r Matrix}\nm1=matrix(nv,nrow=3,ncol=2)\nm1\nclass(nv)#class() function is to show the class of target element, like the type function in Python\nclass(m1)\n#show the dimension\nattributes(nv)\nattributes(m1)# show the dimension of element:(row,colmn)\ndim(m1)#another function can show the dimension as well:(row,colmn)\n\n\nm1[3,2] #print the (3, 2) element of m1\nm1[,2] #print the 2nd column of m1\n\n2*m1 #scalar multiplication\ndiag(2) #identity matrix of dimension 2\nrep(1,2) #replicate 1 twice,this function can create the identity matrix\ncbind(rep(1,6),nv) #put two vectors vertically together to make a matrix\nm3=m1%*%t(m1) #t() is to transpose a matrix and %*% is for matrix multiplication\n\nqr(m3)#A=QR,use QR Decomposition: an orthogonal matrix Q and an upper triangular matrix R. QR decomposition is often used to solve the linear least squares problem, and is the basis for a particular eigenvalue algorithm, the QR algorithm\nqr(m3)$rank #rank of m3\ndiag(m3)#extract the diagonal of a matrix(m3)\n\nsum(diag(m3)) #trace of m3: the trace of an n-by-n square matrix A is defined to be the sum of the elements on the main diagonal (the diagonal from the upper left to the lower right) of A\ndiag(m3)<-1#replace the diagonal of matrix with 1\nsolve(m3) #inverse of m3\n```\n\n## Infinite Values and Missing Data\n\nthe computer software exist several limit on the precision format and 32-bit/64-bit limit\n\n```{r limits on R}\ntypeof(1.9)# another kind of class funtion with more detail in the numeric part, it categories the type of numeric with double(floating), integer number.\n\nas.integer(1.9)# this function transfer the 1.9(double numeric) into the integer number \nis.integer(1.9)# this function judege the type of this number(a),return the pool value:(FASLE or TRUE)\nas.integer(2^31 - 1) #transfer (2^31 - 1) into integer number ,larger than this number  can not  be calculated\n2^1024 #this is also too larger than the upper limits which is based on the 32-bit limit of software\n```\n\n## Probability Related Functions\n\n```{r probability, random and normal distribution}\nrunif(n=10,min = 1,max = 10)# generate 10 random numbers uniformly from 1 to 10\nrnorm(n=10,mean=0,sd=1)# generate 10 normally distributed random numbers with mean=0 and standard deviation =1\nrt(n=10,df=2) # generate 10 random numbers from student t-distribution with df=2 degress of freedom\ndnorm(0.005) # return the density function value of standard normal distribution evaluated at 0.005\npnorm(0.5) # return the cumulative distribution function of standard normal distribution eveluated at 0.5\nqnorm(p=0.25) # return the 0.25th quantile of standard normal distribution(0<=p<=1)\n```\n\n## Other Useful Objetcs\n### Factor object\norganize the data point into different categories.- tag as character variable\nretag the data point with factor tag,\n```{r factor object}\ngender<-factor(c(\"male\",\"male\",\"male\",\"female\",\"female\"))# create two level categories: male and female\nlevels(gender)# show the categories.\n```\n\n### Time Series Object\nuse ts() function to create a special vector with a time index.\n\n```ts(data,start=c(start-year,start-mounth),frequency)``` will create a series of random normally dirtributed numbers (n=100) and order them by mounths, and start mouths is april 1987 (12 mouths as a circle; mounthly times series). if change the freq as 4, so it will create quarterly times series. other freq will not be defined as times series,but based on year.\n\n```{r times series object}\nmyts1=ts(data=rnorm(100),start=c(1987,4),freq = 12)#create a series of random normally dirtributed numbers (n=100) and order them by mounths, and start mouths is april 1987 (12 mouths as a circle; mounthly times series). if change the freq as 4, so it will create quarterly times series. other freq will not be defined as times series,but based on year\ntsp(myts1) # return the start, end time(in numeric format) and frequency\n```\n\n### List Object\nuse list objects(```list()```) to contain the data with different types/classes\n\n```{r List object}\nlobj<-list(name=\"Jack\",stid=123,score=100)# create a list with different attributes,it likes the dictionary in the Python. in the list, there exist the order.\nlobj$name# will print the value of name in list of lobj\nlobj[2]# will print the 2rd element,include the name and value\nlobj[[2]] # will print the value of 2rd element, if there not exist the name, will use the order instead, like \"name\" in lobj will be replace as [[1]] \nlobj2 =vector(mode=\"list\",length = 2)# in the mode, there are three options:\"list\", \"experession\" and \"any\"\nlobj2[[1]]<-lobj # put the lobj into the 2rd element of lobj2\nlobj2[[1]]<-list(name=\"Jack\",stid=123,score=100)# equivalently lobj2[[1]]<-lobj \nlobj2[[2]]<-list(name=\"Mike\",stid=245,score=60)\nlobj2[[1]]$stid # the find student's ID number\nlobj2[[2]][[3]] # the second student's score\n```\n\n\n### Dataframe Object\nthe dataframe is the most important function for data mining and data analysis, and it can help us to contain exteran data file into R. and almost all the data will be handle in the dataframe\nuse ```setwd()``` fucntion to set up the working directory, that can help us more easy to import the data and\n#### set up working directory and import data \n```{r setwrkdir&importdata}\nsetwd(\"/Users/sn0wfree/Dropbox/PhD(1st)/sn0wfree.github.io/BST169_Econometrics/computing/session1-5\")#setup the working directory\nlondon<-read.csv('london.csv')# import data from london.csv\nclass(london)\ntypeof(london)\n\n```\n#### structure, head and colname\nnow about look the structure of data,  head of data and  the label or colmn's name\n```{r str,colname and head}\nstr(london)# show the structure of data, include the types, observation and variables\nhead(london)# show first 6 row \ncolnames(london)# show the label or colmn's name, also called the variables' name\nlondon$wcloth# show the wcloth variable in the london dataset.\nlondon[,1]=as.character(london[,1])# reset the 1st column as.character\n```\n\n### Some Statistical Functions\nSome useful Statistical Functions\n```{r Some Statistical Functions}\nsum(london$income)#sum of the income of all obervations in london dataset\nmean(london$income)\nvar(london$income)\nsd(london$income)\nquantile(london$income)\nhist(london$income,breaks=10000,freq = FALSE)# draw a histogram based on london$income, the breaks is the number of cells,freq: show the freqency of not, if FALSE(or 0) present Density, if TRUE(or 1) present freqency\nhist(london$income,breaks=1000,freq = FALSE)\nhist(london$income,breaks=100,freq = FALSE)\nhist(london$income,breaks=10,freq = FALSE)\nhist(london$income,breaks=10,freq = TRUE)\nplot(london$income)\nplot(london$income,london$totexp)\nboxplot(london$income,london$totexp)#draw a boxplot\nqqnorm(london$income)#plot the qq-plot\nwhich(london$income>140)#return the indices for observations with income higher than 140.\ncov(london$income,london$totexp)# show the sample covariance between income and total expenditure.\ncor(london[,2:11])#sample correlation matrix for the 2-11 variables(columns) in london\nsummary(london[,2:11])#summary some statistics for the 2-11 variables(columns) in london\ncolSums(london[,2:11])# return the column sums of the 2-11 variables in \n#rowSums(london[2:11,])# return the row sums of the 2-11 rows in london\n```\n\nQuestion 1: Can you find out which variables have missing obervation(s)? in what positions?\n\n**1st: use manual way to seek the missing data**\n```{r Answer to Question 1:scan_the_missing_data:Manual}\n\n#colSums(london)# 2 columns:wcloth and walc\n#rowSums(london)# 2 rows: 10 and 15\n\nlondon$wcloth[10]#NA\nlondon$walc[15]#NA\nis.na(london$wcloth[1:20])\n```\n\n**2rd: use auto way to seek the missing data**\n```{r  Answer to Question 1:scan_the_missing_data:Auto}\nsetwd(\"/Users/sn0wfree/Dropbox/PhD(1st)/sn0wfree.github.io/BST169_Econometrics/computing/session1-5\")#setup the working directory\nlondon<-read.csv('london.csv')# import data from london.csv\n\ncompare_missing_data_function<-function(symbol){\n  b<-c()\n  for (i in 1:length(symbol)){\n    if(is.na(symbol[i])==TRUE){\n      b=append(b,i)\n    }\n  }\n  return(b)\n}\n\nseek_missing_data<- function(data){\n  missing_data_location<-c()\n  missing_col_number<-compare_missing_data_function(colSums(data))\n  missing_row_number<-compare_missing_data_function(rowSums(data))\n  for(i in missing_col_number){\n    for(j in missing_row_number){\n      if (is.na(data[j,i])==TRUE){\n        missing_data_location<-append(missing_data_location,c(names(data)[i],j))}\n      }\n  }\n  return(missing_data_location)\n}\n\nseek_missing_data(london)\n```\n\n## Least Squares Regression\n\n### OLS\n\n```{r OLS}\nlmobj<-lm(wfood~log(totexp)+log(income),data=london)\nsummary(lmobj)#summary of the fitted model\ntypeof(lmobj)# is a list\nclass(lmobj)# is a \"lm\"\n```\n\n```typeof(lmobj)``` and ```class(lmobj)``` have different return value\n\n```{r some values}\ncoef(lmobj)#estimated model parameters (estimated_beta of OLS) \nhead(resid(lmobj)) #estimated residuals M_{x,y}\nhead(fitted(lmobj)) #fitted values of the model (P_{x,y}) \ndeviance(lmobj) #the residual sum of squares (SSR or y'M_{x,y}) \nconfint(lmobj) #confidence interval\nlogLik(lmobj) #value of the log likelihood function (assume normal er- ror)\nAIC(lmobj,k=2) #information criterion, k = 2 for AIC and k = log(N) for BIC (assume normal error, to be covered later)\nvcov(lmobj)# estimated-beta OLSâ€™s estimated variance-covariance matrix (\\espison^{hat}_{2}(X'X)_{-1}) \nanova(lmobj) #returns an anova table; ANOVA analysis\npredict(lmobj,data.frame(totexp=1,income=1)) #returns predictions \npar(mfrow=c(1,2))#par graphes by 2*2\nplot(lmobj) #create diagnostic plots\npar(mfrow=c(1,1))#restore the default one\n```\n\nQuestion 2: Can you use matrix algebra in R to reproduce the outputs of the following functions:\n\n  1. ```coef(lmobj)```\n  \n  2. ```resid(lmobj)```\n  \n  3. ```fitted(lmobj)```\n  \n  4. ```deviance(lmboj)```\n  \n  5. ```vcov(lmboj)```\n  \nEquation:\n\n  1). the normal form :\n\\begin{center} \n$wfood=\\beta_0+\\beta_1*totexp+\\beta_2*income+\\epsilon$\n\\end{center}\n  2). the matrix form:\n  \n\\begin{center} \n$wfood = x*\\beta + \\epsilon$\n\\end{center}\nhere, \n\\begin{center} \n$x= \n|\\begin{matrix}\n\\beta_0 & totexp & income\n\\end{matrix}$|\n\\end{center}\n\nbecause the matrix form can be easy solved out\nthus, i show the solution of this OLS methods:\n\nthe OLS mainly aims to solve the $\\beta$, based on the minimum of Sum Squared Residuals(SSR):\n\nin normal form\n\\begin{center} \n$SSR=\\sum_{i=1}^N\\epsilon^2$\n\\end{center}\n\nin matrix form\n\\begin{center} \n$SSR=(wfood-x\\beta)'*(wfood-x\\beta)$\n\\end{center}\n\nand minimize the SSR \n\n\\begin{center} \n$\\min{SSR}=\\min{(wfood-x\\beta)'*(wfood-x\\beta)}$\n\\end{center}\n\nfor minimum, i make the 1st different should as zero. Thus,\n\\begin{center}\n$\\frac{\\mathrm{d}(wfood-x\\beta)'*(wfood-x\\beta)}{\\mathrm{d}\\beta}=0$\n\\end{center}\n\n\\begin{center}\n$\\frac{\\mathrm{d}(wfood-x\\beta)'*(wfood-x\\beta)}{\\mathrm{d}\\beta}=\\frac{\\mathrm{d}(wfood'-\\beta'x')*(wfood-x\\beta)}{\\mathrm{d}\\beta}=0$\n\\end{center}\n\n\\begin{center}\n$\\frac{\\mathrm{d}(wfood-x\\beta)'*(wfood-x\\beta)}{\\mathrm{d}\\beta}=\\frac{\\mathrm{d}(wfood'*wfood-2\\beta'x'y+\\beta'x'x\\beta)}{\\mathrm{d}\\beta}=0$\n\\end{center}\nhere, the $wfood'*wfood$ and $\\beta'x'y$ are non-beta martix or single-beta matrix, after differentiate on $\\beta$, there will left 0 and the coefficent of single-beta:$x'y$. Thus,\n\\begin{center}\n$\\frac{\\mathrm{d}(wfood-x\\beta)'*(wfood-x\\beta)}{\\mathrm{d}\\beta}=0-2x'y+2x'x\\beta=0$\n\\end{center}\nand \n\\begin{center}\n$\\beta=(x'x)^{-1}x'y$\n\\end{center}\nthat is the solution of beta from OLS methods\n\n```{r Answer to Question 2}\nx<-cbind(rep(1,length(london$wfood)),log(london$totexp),log(london$income))# create the martix x in the equation (1)\ncoef_of_lmboj<-solve(t(x)%*%x)%*%t(x)%*%london$wfood#coef(lmobj)\ncoef(lmobj)\ncoef_of_lmboj\n\n\nfitted_of_lmobj<-x%*%coef_of_lmboj#fitted(lmobj)\nhead(fitted(lmobj))\nhead(fitted_of_lmobj)\n\nresid_of_lmobj<-london$wfood-x%*%coef_of_lmboj#resid(lmobj)\nhead(resid(lmobj))\nhead(resid_of_lmobj)\n\ndeviance_of_lmobj<-t(resid_of_lmobj)%*%resid_of_lmobj#just calulate the SSR,equal to deviance(lmobj)\nhead(deviance(lmobj))\nhead(deviance_of_lmobj)\n\nvcov(lmobj)\n```\n\n  \n\n",
    "created" : 1478992272768.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1420628166",
    "id" : "7CD614E7",
    "lastKnownWriteTime" : 1479323781,
    "last_content_update" : 1479323781856,
    "path" : "~/Dropbox/PhD_1st_study/BST169_Econometrics/Computing/session1-5/Session1-5 for Econometrics.Rmd",
    "project_path" : "Session1-5 for Econometrics.Rmd",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}